package com.fit.kmm.khttpimport com.fit.kmm.khttp.ui.IKLoadingimport com.fit.kmm.khttp.ui.IKToastimport com.fit.kmm.kloger.KLogerimport com.fit.kmm.thread.ioScopeimport com.fit.kmm.thread.uiScopeimport io.ktor.client.HttpClientimport io.ktor.client.call.bodyimport io.ktor.client.plugins.HttpTimeoutimport io.ktor.client.plugins.logging.LogLevelimport io.ktor.client.plugins.logging.Loggerimport io.ktor.client.plugins.logging.Loggingimport io.ktor.client.plugins.timeoutimport io.ktor.client.request.forms.FormDataContentimport io.ktor.client.request.getimport io.ktor.client.request.postimport io.ktor.client.request.setBodyimport io.ktor.client.statement.bodyAsTextimport io.ktor.http.Headersimport io.ktor.http.Parametersimport io.ktor.utils.io.core.Inputimport io.ktor.utils.io.core.readAvailableimport io.ktor.utils.io.core.useimport kotlinx.coroutines.launchimport kotlin.collections.set/** * ktor wrapper for net request. * */class KtorHelper : BaseNetHelper() {    companion object {        const val NET_ERROR_TIP = "网络异常，请稍后再试..."        fun with(): KtorHelper {            return KtorHelper()        }        private val httpClient: HttpClient by lazy {            HttpClient {                install(HttpTimeout)                install(Logging) {                    level = LogLevel.ALL                    logger = object : Logger {                        override fun log(message: String) {                            KLoger.v("http ===> $message")                        }                    }                }            }        }    }    override fun withTimeout(to: Long) = this.apply {        super.withTimeout(to)    }    override fun withLoading(l: IKLoading?) = this.apply {        super.withLoading(l)    }    override fun withErrorToast(b: IKToast?) = this.apply {        super.withErrorToast(b)    }    /**     * set the http request header, only post request used.     * @param header the header     * */    override fun withHeader(header: Map<String, String>) = this.apply {        super.withHeader(header)    }    /**     * 添加cookie到header中     **/    override fun withCookie(cookie: Map<String, Any>) = this.apply {        super.withCookie(cookie)    }    /**     * http post request     * @param url the url which will be request.     * @param iNet callback of the request     * */    override fun jsonPost(url: String, params: Map<String, Any>, iNet: INet) {        reqHeader["Content-Type"] = "application/json"        start(url, METHOD_POST, params, iNet)    }    /**     * http post request     * @param url the url which will be request.     * @param iNet callback of the request     * */    override fun jsonStrPost(url: String, jsonMap: Map<String, Any>, iNet: INet) {        reqHeader["Content-Type"] = "application/json"        start(url, METHOD_POST, jsonMap, iNet)    }    /**     * http post request with Content-Type: application/x-www-form-urlencoded     * @param url the url which will be request.     * @param iNet callback of the request     * */    override fun formPost(url: String, params: Map<String, Any>, iNet: INet) {        start(url, METHOD_POST, FormDataContent(Parameters.build {            params.forEach {                append(it.key, "${it.value}")            }        }), iNet)    }    /**     * http get request     * @param url the url which will be request.     * @param iNet callback of the request     * */    override fun get(url: String, iNet: INet) = start(url, METHOD_GET, null, iNet)    /**     * http get/ post request     * @param url the url which will be request.     * @param body the request body     * @param iNet callback of the request     * @param method 网络请求的方式     * */    private fun start(url: String, method: String, reqBody: Any?, iNet: INet) {        loading?.show()        ioScope.launch {            kotlin.runCatching {                if (method == METHOD_GET) {                    httpClient.get(url) {                        timeout {                            requestTimeoutMillis = timeout                        }                    }                } else {                    httpClient.post(url) {                        if (null != reqBody) {                            this.setBody(reqBody)                        }                        reqHeader.forEach {                            this.headers.append(it.key, it.value)                        }                        timeout {                            requestTimeoutMillis = timeout                        }                    }                }            }.onSuccess {                uiScope.launch {                    loading?.dismiss()                    try{                        iNet.back(RET_SUCCESS, okHeader2Map(it.headers), it.bodyAsText())                    } catch(e: Throwable) {                        e.printStackTrace()                    }                }            }.onFailure {                uiScope.launch {                    loading?.dismiss()                    toast?.show(NET_ERROR_TIP)                    try{                        iNet.back(RET_FAIL, mutableMapOf(),"${it.message}")                    } catch(e: Throwable) {                        e.printStackTrace()                    }                }            }        }    }    /**     * http get request for bytes     * @param url the url which will be request.     * @param callback callback of the request, contains bytes of the request.     * */    override fun download(url: String, callback: INetDownload) {        loading?.show()        ioScope.launch {            kotlin.runCatching {                httpClient.get(url) {                    timeout {                        requestTimeoutMillis = timeout                    }                }            }.onSuccess { response ->                uiScope.launch {                    loading?.dismiss()                    try{                        response.body<Input>().use {                            callback.back(RET_SUCCESS, okHeader2Map(response.headers), ByteArray(it.remaining.toInt()).apply {                                it.readAvailable(this)                            })                        }                    } catch(e: Throwable) {                        e.printStackTrace()                    }                }            }.onFailure {                uiScope.launch {                    loading?.dismiss()                    toast?.show(NET_ERROR_TIP)                    try{                        callback.back(RET_FAIL, mutableMapOf(), byteArrayOf())                    } catch(e: Throwable) {                        e.printStackTrace()                    }                }            }        }    }    //将okhttp请求的header转换成map    private fun okHeader2Map(header: Headers): Map<String, List<String>> {        val map = mutableMapOf<String, List<String>>()        header.forEach { key, list ->            map[key] = list        }        return map.toMap()    }}